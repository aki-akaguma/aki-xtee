### `aki-xtee` Design Document

This document outlines the software design for the `aki-xtee` utility, based on the acceptance criteria and an analysis of the source code.

#### 1. High-Level Architecture

`aki-xtee` is a command-line application with a simple, linear data flow architecture. It is designed as a pipe-through utility, reading from a single source (stdin) and writing to multiple destinations (stdout and various files) simultaneously.

The core architectural pattern is a **multiplexer**. A central processing loop reads data in chunks from standard input and dispatches each chunk to a collection of "writers". This ensures that all outputs receive the same data in the same order.

A key design choice is the use of Rust's trait objects (`Box<dyn std::io::Write>`) to create a homogeneous collection of writers from heterogeneous sources (stdout, plain files, compressed files). This allows the core logic to remain agnostic about the specific type of output it's writing to, promoting modularity and extensibility.

#### 2. Component Breakdown

The application's logic is organized into several distinct modules within the `src` directory.

*   **`main.rs`**: The application entry point.
    *   **Responsibility:** Parses command-line arguments by calling the `conf` module, then invokes `run::run()` to execute the main logic. It is the thin "executable" layer.

*   **`lib.rs`**: The library crate root.
    *   **Responsibility:** Exposes the core functionality as a reusable library. This is useful for integration testing and potential use in other applications.

*   **`run.rs`**: The core processing logic.
    *   **Responsibility:**
        1.  Initializes a vector of `Box<dyn std::io::Write>` objects. The first writer is always `std::io::stdout()`.
        2.  Iterates through the file arguments provided by the user.
        3.  For each file, it calls `util::adapt_output::from_path()` to create the appropriate file writer (plain or compressed).
        4.  Enters a loop, reading data from `std::io::stdin()` into a buffer.
        5.  In the loop, it iterates through the vector of writers and writes the buffer's contents to each one.
        6.  Handles I/O errors during the read/write loop.

*   **`conf/`**: Configuration and argument parsing module.
    *   **`conf/parse.rs`**: Uses an external crate (like `clap`) to define and parse the CLI arguments (`<file>...`, `--help`, `--version`). It translates the raw arguments into a structured `Config` object for use by the rest of the application.
    *   **`conf/mod.rs`**: Declares the `parse` submodule.

*   **`util/`**: Utility and helper module.
    *   **`util/adapt_output.rs`**: Implements the factory for creating writers.
        *   **`from_path(path: &Path)`**: This is the key function. It inspects the file extension of the given path. Based on the extension (e.g., `.gz`, `.xz`), it delegates the creation of the writer to the corresponding submodule in `util/compress/`. For unknown extensions, it defaults to a plain `File::create()`. It returns a `Box<dyn Write>`, abstracting away the specific implementation.
    *   **`util/compress/`**: Compression module.
        *   **`mod.rs`**: Declares all the specific compression format submodules.
        *   **`plain.rs`, `gz.rs`, `xz.rs`, `zst.rs`, `bzip2.rs`, `lz4.rs`**: Each of these files provides a function that takes a file path, creates the file, and wraps it in a specific compression encoder from an external library (e.g., `flate2::write::GzEncoder`, `xz2::write::XzEncoder`). The result is returned as a `Box<dyn Write>`.
    *   **`util/err.rs`**: Defines the custom `XteeError` enum for the application, allowing for standardized error handling.

#### 3. Data Flow

The data flow is sequential and straightforward:

1.  **Start**: User executes `aki-xtee file1.txt file2.gz`.
2.  **`main.rs`**: The `main` function is called.
3.  **`conf::parse`**: The arguments `file1.txt` and `file2.gz` are parsed into a `Config` struct.
4.  **`run::run`**: The `run` function is called with the `Config`.
5.  **Writer Initialization**:
    *   A `Vec<Box<dyn Write>>` is created.
    *   `stdout` is added to the vector.
    *   `util::adapt_output::from_path("file1.txt")` is called. It sees no special extension and returns a `Box<File>`. This is added to the vector.
    *   `util::adapt_output::from_path("file2.gz")` is called. It sees the `.gz` extension, calls `util::compress::gz::writer`, and returns a `Box<GzEncoder<File>>`. This is added to the vector.
6.  **Processing Loop**:
    *   `run` reads a chunk of data from `stdin` (e.g., 64KB).
    *   It loops through its vector of three writers.
    *   It calls `.write_all()` on the `stdout` writer.
    *   It calls `.write_all()` on the `File` writer for `file1.txt`.
    *   It calls `.write_all()` on the `GzEncoder` writer for `file2.gz`.
    *   This repeats until `stdin` is closed.
7.  **Finish**: The program exits. The `Drop` trait on the writers ensures all buffers are flushed and files are closed correctly.

#### 4. Key Design Patterns

*   **Strategy Pattern / Polymorphism**: The use of `Box<dyn std::io::Write>` is the cornerstone of the design. It allows the main loop to treat all destinations uniformly, whether they are uncompressed files, compressed files, or standard output. The specific "strategy" for writing is chosen at runtime based on the file extension.
*   **Factory Pattern**: The `util::adapt_output::from_path` function acts as a factory. It encapsulates the logic for creating different types of writer objects based on an input (the file path). This decouples the core `run` logic from the concrete implementation details of each compression format.
*   **Modularization**: The code is cleanly separated into modules with distinct responsibilities: argument parsing (`conf`), core logic (`run`), and output handling (`util`). This makes the code easier to understand, maintain, and test.
